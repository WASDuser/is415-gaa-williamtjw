---
title: "Take-Home Exercise 1: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar"
author: "William"
date: "September 7, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

# Objectives

I will be using armed conflict [data](https://acleddata.com/data-export-tool/) of Myanmar from January 2021 to June 2024, aka Armed Conflict Location & Event Data (ACLED).

I will be focusing on thsese main event types:

-   Battles,

-   Explosion/Remote violence,

-   Strategic developments, and

-   Violence against civilians.

Along the way, I will be exploring the use of different functions to obtain more aesthetically pleasing outputs for fun.

# Data

## Packages

These R packages will be used:

-   **sf**: importing, managing, and processing geospatial data, and

-   **tidyverse**: performing data science tasks such as importing, wrangling and visualising data.

-   **readr**

    -   `read_csv()`: reading ACLED csv data

-   **janitor**: data cleaning

-   **lubridate**: date formatting

-   **Extra (TBD):**

    -   **janitor**: data cleaning

    -   **lubridate**: date formatting

    -   **skimr**: provide summary statistics

    -   **scrutiny**: data wrangling

    -   cowplot - add-on to ggplot for higher quality figures

    -   [htmlwidgets](https://www.htmlwidgets.org/showcase_leaflet.html) for R - interactive visualisations (could be used for visual analytics)

        -   leaflet - geo-spatial mapping

    -   raster: `raster()`

    -   terra: `writeRaster()`

```{r}
pacman:::p_load(sf,tidyverse,spatstat,raster,janitor,skimr,lubridate,tmap) # more to be added
```

## ACLED

```{r}
#| eval: false
acled_sf <- read_csv('data/2021-01-01-2024-07-01-Myanmar.csv')
```

## Metadata

Click to expand –\>

<details>

+----------------------+----------------------------------------------------------------------------------------------------------+
| Variable             | Description                                                                                              |
+======================+:=========================================================================================================+
| 'event_id_cnty'      | unique alphanumeric ID by number & country acronym                                                       |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'event_date'         | day-month-year of event                                                                                  |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'year'               | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'time_precison'      | numeric code for level of precison of data records                                                       |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'disorder_type'      | i.e. 'Demonstrations','Political violence','Political violence; Demonstrations','Strategic developments' |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'event_type'         | nature of event                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'sub_event_type'     | provides further classification to event_type                                                            |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'actor1'             | involved actors along with their respective affiliates                                                   |
|                      |                                                                                                          |
| 'assoc_actor_1'      |                                                                                                          |
|                      |                                                                                                          |
| 'actor2'             |                                                                                                          |
|                      |                                                                                                          |
| 'assoc_actor_2'      |                                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'inter1'             | numeric code between 0 and 8 encoding different actors\                                                  |
|                      |                                                                                                          |
| 'inter2'             |                                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'interaction'        | indicates the 2 actor types interacting in the event (encoded inter1 & inter2 by concatenation)          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'civilian_targeting' | indicates whether the event involved civilian targeting (e.g. null if false)                             |
|                      |                                                                                                          |
|                      | -   **Note: no data format irregularity**                                                                |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'iso'                | unique 3-digit numeric code assigned to each country or territory according to ISO 3166                  |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'region'             | region of the world where the event took place                                                           |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'country'            | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'admin1'             | national administrative regions where the event took place (admin1 being the largest)                    |
|                      |                                                                                                          |
| 'admin2'             |                                                                                                          |
|                      |                                                                                                          |
| 'admin3'             |                                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'location'           | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'latitude'           | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'longitude'          | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'geo_precision'      | numeric code for level of precison of event location                                                     |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'source'             | source of event report                                                                                   |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'source_scale'       | scale (e.g. local, international) of the source                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'notes'              | description of the event                                                                                 |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'fatalities'         | number of reported fatalities in the event                                                               |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'tags'               | targets (type and estimate counts)                                                                       |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'time'               | Unix Timestamp of event                                                                                  |
+----------------------+----------------------------------------------------------------------------------------------------------+

</details>

## Myammar's Administrative Boundary data

**Background:**

-   admin 0: country boundary (full overview)

-   1: state/region

-   2: district-level

-   3: township (greatest resolution)

**Approach:**

1.  In the working file directory, group the shapefiles according to admin classification (admin0, admin1, etc.)

2.  Load

3.  Check structure and boundary plot

For the purposes of exploring the differences in detail:

::: panel-tabset
### admin 0

```{r}
#| eval: false
the1_mymr_shp4326_admin0 <- st_read(dsn = 'data/gadm41_MMR_0/', layer = 'gadm41_MMR_0')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin0)

# geometry: "XY" "MULTIPOLYGON"
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin0$geometry)
```

### admin 1

```{r}
#| eval: false
the1_mymr_shp4326_admin1 <- st_read(dsn = 'data/gadm41_MMR_1/', layer = 'gadm41_MMR_1')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin1)
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin1$geometry)
```

### admin 2

```{r}
#| eval: false
the1_mymr_shp4326_admin2 <- st_read(dsn = 'data/gadm41_MMR_2/', layer = 'gadm41_MMR_2')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin2)
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin2$geometry)
```

### admin 3

```{r}
#| eval: false
the1_mymr_shp4326_admin3 <- st_read(dsn = 'data/gadm41_MMR_3/', layer = 'gadm41_MMR_3')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin3)
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin3$geometry)
```
:::

### Study Area

To balance spatial detail and computational efficiency, I think using `the1_mymr_shp4326_admin1` (state/region) boundary data will be the best fit. While looking at district-/township-level provides fine granularity for analysis, for potato machines like my macbook, `the1_mymr_shp4326_admin1` provides the best compromise.

```{r}
#| eval: false
summary(the1_mymr_shp4326_admin1)
```

# Data Wrangling

In this section, I will be doing basic data cleaning and formatting across the ACLED columns so that I can derive appropriate variables needed for analysis.

**Inspecting ACLED**

```{r}
#| eval: false
head(acled_sf, n=5)
```

**Check ACLED structure**

```{r}
#| eval: false
str(acled_sf)
```

**Check `event_type` values**

```{r}
#| eval: false
unique(acled_sf$event_type)
```

**Check for Missing Data**

```{r}
#| eval: false
sum(is.na(acled_sf))
```

Clearly, this doesn't provide much insight to the state of the ACLED **columns**. Hence I consulted Uncle Google for alternatives:

-   base R

```{r}
#| eval: false
acled_sf %>% 
  summarise(across(everything(), ~ sum(is.na(.)))) %>% 
  
  # pivot_longer() to transpose the table for a more compact output
  pivot_longer(everything(), names_to = "column", values_to = "missing_count") %>%
  
  # filter() to rid off ACLED columns with no missing data.
  filter(missing_count > 0)
```

> Notes from output:
>
> '`actor`'-related columns: possible to have 1 or more actors responsible
>
> '`civilian_targeting`': boolean-like variable — null for no civilian targeting
>
> '`admin3`': location identifiers are still discernible at least 1 of the `admin` columns are filled
>
> '`tags`': supplementary target description information
>
> Hence, `missing_count` values can be ignored.

-   `skim()` from `skimr` package

```{r}
#| eval: false
skim(acled_sf) %>%
  tibble::as_tibble()

# n_missing, character.n_unique, various summary statistics are somwhat useful; added here for extra reference
```

**Checking for duplicates in ACLED's unique identifier `event_id_cnty`**

-   base R

```{r}
#| eval: false
sum(duplicated(acled_sf['event_id_cnty'])) # no duplicates
```

## Wrangling

#### **Reference system**

```{r}
#| eval: false
st_crs(acled_sf)
```

```{r}
#| eval: false
acled_sf <- acled_sf %>% 
  st_as_sf(coords = c('longitude','latitude'), crs = 4326) %>% 
  st_transform(crs = 32646)
st_crs(acled_sf) # last line: ID["EPSG",32646]]
```

```{r}
#| eval: false
st_crs(the1_mymr_shp4326_admin1) # last line: ID["EPSG",4326]]
```

```{r}
#| eval: false
the1_mymr_shp32646_admin1 <- the1_mymr_shp4326_admin1 %>% 
  st_transform(crs = 32646)
st_crs(the1_mymr_shp32646_admin1) # now should be: ID["EPSG",32646]]
```

#### **Date format**

-   `lubridate` package

    -   `as_datetime()`: converts UNIX time-stamps into workable date-time object

    -   `quarter()`: extracts quarter info

```{r}
#| eval: false
# to-do: assign variable; mix in geospatial data too
acled_sf_prepped <- acled_sf %>% 
  group_by(event_id_cnty) %>%
  arrange(timestamp) %>% 
  mutate(
    # convert UNIX timestamp into datetime object
    datetime = as_datetime(timestamp, tz = 'Asia/Yangon'),
    
    # extract quarter info
    quarter_num = quarter(datetime),
    
    # concatenate
    quarter_period = paste(year,'Q', quarter_num, sep = '')
  )
```

> Note: Unix timestamps count the number of seconds since the Unix epoch (January 1st, 1970 at UTC)

## Saving Derived Data

Save working data files and check data structures and attributes if needed before proceeding with analysis

::: panel-tabset
### ACLED

```{r}
#| eval: false
acled_sf_prepped
```

### Boundary shapefile

```{r}
#| eval: false
the1_mymr_shp32646_admin1
```

### Derived Datasets

```{r}
#| eval: false
# refer to previously, 
# "Strategic developments"
# "Explosions/Remote violence"
# "Battles"
# "Protests"
# "Violence against civilians"
# "Riots"

acled_stratdev_sf <- acled_sf_prepped %>% 
  filter(event_type=='Strategic developments') %>% 
  select(1,33,30)

acled_explo_sf <- acled_sf_prepped %>% 
  filter(event_type=='Explosions/Remote violence') %>% 
  select(1,33,30)

acled_battle_sf <- acled_sf_prepped %>% 
  filter(event_type=='Battles') %>% 
  select(1,33,30)

acled_protest_sf <- acled_sf_prepped %>% 
  filter(event_type=='Protests') %>% 
  select(1,33,30)

acled_civi_sf <- acled_sf_prepped %>% 
  filter(event_type=='Violence against civilians') %>% 
  select(1,33,30)

acled_riot_sf <- acled_sf_prepped %>% 
  filter(event_type=='Riots') %>% 
  select(1,33,30)

write_rds(acled_stratdev_sf, 'data/rds/acled_stratdev_sf.rds')
write_rds(acled_explo_sf, 'data/rds/acled_explo_sf.rds')
write_rds(acled_battle_sf, 'data/rds/acled_battle_sf.rds')
write_rds(acled_protest_sf, 'data/rds/acled_protest_sf.rds')
write_rds(acled_civi_sf, 'data/rds/acled_civi_sf.rds')
write_rds(acled_riot_sf, 'data/rds/acled_riot_sf.rds')

write_rds(acled_sf_prepped, 'data/rds/acled_sf_prepped.rds')
write_rds(the1_mymr_shp32646_admin1, 'data/rds/the1_mymr_shp32646_admin1.rds')
# event_id_cnty,1
# quarter_period,33
# geometry,30
```
:::

# RDS Checkpoint

```{r}
acled_sf_prepped <- read_rds('data/rds/acled_sf_prepped.rds')
the1_mymr_shp32646_admin1 <- read_rds('data/rds/the1_mymr_shp32646_admin1.rds')

acled_stratdev_sf <- read_rds('data/rds/acled_stratdev_sf.rds')
acled_explo_sf    <- read_rds('data/rds/acled_explo_sf.rds')
acled_battle_sf   <- read_rds('data/rds/acled_battle_sf.rds')
acled_protest_sf  <- read_rds('data/rds/acled_protest_sf.rds')
acled_civi_sf     <- read_rds('data/rds/acled_civi_sf.rds')
acled_riot_sf     <- read_rds('data/rds/acled_riot_sf.rds')
```

# KDEs

## Overview

### Creating `ppp` object

**`as.ppp()` from `spatstat.geom`**

```{r}
acled_ppp <- as.ppp(acled_sf_prepped)
summary(acled_ppp)
```

### Creating `owin` object of `admin1` boundary

```{r}
the1_mymr_shp4326_admin1_owin <- as.owin(the1_mymr_shp32646_admin1)
```

### Combine ppp and owin

```{r}
acled_ppp <- acled_ppp[the1_mymr_shp4326_admin1_owin]
```

### Rescale `m` to `km`

```{r}
acled_ppp_km <- rescale.ppp(acled_ppp,1000,'km')
```

Varying admin1 geographical boundaries — ideal adaptive bandwidth KDE, but because of **computational limitation**, fixed BW is used**:**

```{r}
kde_acled_bw_diggle <- density(
  acled_ppp_km,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
```

```{r}
kde_acled_bw_scott <- density(
  acled_ppp_km,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
```

```{r}
kde_acled_bw_ppl <- density(
  acled_ppp_km,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)
```

```{r}
kde_acled_bw_cvl <- density(
  acled_ppp_km,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
) # choosing this
```

```{r}
par(mfrow=c(1,4))
plot(kde_acled_bw_cvl)
plot(kde_acled_bw_diggle)
plot(kde_acled_bw_ppl)
plot(kde_acled_bw_scott)
```

# `event_type` Exploratory Analysis by Quarter

## Battles

### Generate KDE Layers

```{r}
#| warning: false
# initialise
quarters <- unique(acled_battle_sf$quarter_period)
kde_battles_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_battle_sf_qtr <- acled_battle_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_battle_ppp_qtr <- as.ppp(acled_battle_sf_qtr)

    # create owin object
    acled_battle_ppp_qtr <- acled_battle_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_battle_ppp_km_qtr <- rescale.ppp(acled_battle_ppp_qtr,1000,'km')
    
    # compute KDE
    kde_acled_battle_qtr_bw_cvl <- density(
      acled_battle_ppp_km_qtr,
      sigma=bw.CvL,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_battles_list[[quarter]] <- kde_acled_battle_qtr_bw_cvl
    print('qtr done!')
}

kde_battles_list
```

### Visualise KDE Layers

```{r}
for (quarter in names(kde_battles_list)) {
    plot(kde_battles_list[[quarter]], main = paste("KDE for", quarter))
}
```

### Converting KDE output into grid object

```{# {r}
# for (quarter in names(kde_battles_list)) {
#     raster_kde_battles <- raster(kde_battles_list[[quarter]])
# }

```

## Explosions/Remote violence

```{r}
#| warning: false
# initialise
quarters <- unique(acled_explo_sf$quarter_period)
kde_explo_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_explo_sf_qtr <- acled_explo_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_explo_ppp_qtr <- as.ppp(acled_explo_sf_qtr)

    # create owin object
    acled_explo_ppp_qtr <- acled_explo_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_explo_ppp_km_qtr <- rescale.ppp(acled_explo_ppp_qtr,1000,'km')
    
    # compute KDE
    kde_acled_explo_qtr_bw_cvl <- density(
      acled_explo_ppp_km_qtr,
      sigma=bw.CvL,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_explo_list[[quarter]] <- kde_acled_explo_qtr_bw_cvl
    print('qtr done!')
}

kde_explo_list
```

```{r}
for (quarter in names(kde_explo_list)) {
    plot(kde_explo_list[[quarter]], main = paste("KDE for", quarter))
}
```

## Protests

```{r}
#| warning: false
# initialise
quarters <- unique(acled_protest_sf$quarter_period)
kde_protest_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_protest_sf_qtr <- acled_protest_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_protest_ppp_qtr <- as.ppp(acled_protest_sf_qtr)

    # create owin object
    acled_protest_ppp_qtr <- acled_protest_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_protest_ppp_km_qtr <- rescale.ppp(acled_protest_ppp_qtr,1000,'km')
    
    # compute KDE
    kde_acled_protest_qtr_bw_cvl <- density(
      acled_protest_ppp_km_qtr,
      sigma=bw.CvL,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_protest_list[[quarter]] <- kde_acled_protest_qtr_bw_cvl
    print('qtr done!')
}

kde_protest_list
```

```{r}
for (quarter in names(kde_protest_list)) {
    plot(kde_protest_list[[quarter]], main = paste("KDE for", quarter))
}
```

## Riots (TBD)

```{r}
#| eval: false
# initialise
quarters <- unique(acled_riot_sf$quarter_period)
quarters
kde_riot_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_riot_sf_qtr <- acled_riot_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_riot_ppp_qtr <- as.ppp(acled_riot_sf_qtr)

    # create owin object
    acled_riot_ppp_qtr <- acled_riot_ppp_qtr[the1_mymr_shp4326_admin1_owin]

    # rescale to KM
    acled_riot_ppp_km_qtr <- rescale.ppp(acled_riot_ppp_qtr,1000,'km')

    # compute KDE
    kde_acled_riot_qtr_bw_cvl <- density(
      acled_riot_ppp_km_qtr,
      sigma=bw.CvL,
      edge=TRUE,
      kernel='gaussian'
    )

    # Append to list
    kde_riot_list[[quarter]] <- kde_acled_riot_qtr_bw_cvl
    print('qtr done!')
}

kde_riot_list
```

```{r}
#| eval: false
for (quarter in names(kde_riot_list)) {
    plot(kde_riot_list[[quarter]], main = paste("KDE for", quarter))
}
```

## Strategic developments

```{r}
#| warning: false
# initialise
  quarters <- unique(acled_stratdev_sf$quarter_period)
kde_stratdev_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_stratdev_sf_qtr <- acled_stratdev_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_stratdev_ppp_qtr <- as.ppp(acled_stratdev_sf_qtr)

    # create owin object
    acled_stratdev_ppp_qtr <- acled_stratdev_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_stratdev_ppp_km_qtr <- rescale.ppp(acled_stratdev_ppp_qtr,1000,'km')
    
    # compute KDE
    kde_acled_stratdev_qtr_bw_cvl <- density(
      acled_stratdev_ppp_km_qtr,
      sigma=bw.CvL,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_stratdev_list[[quarter]] <- kde_acled_stratdev_qtr_bw_cvl
    print('qtr done!')
}

kde_stratdev_list
```

```{r}
for (quarter in names(kde_stratdev_list)) {
    plot(kde_stratdev_list[[quarter]], main = paste("KDE for", quarter))
}
```

## Violence against civilians

```{r}
#| warning: false
# initialise
quarters <- unique(acled_civi_sf$quarter_period)
kde_civi_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_civi_sf_qtr <- acled_civi_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_civi_ppp_qtr <- as.ppp(acled_civi_sf_qtr)

    # create owin object
    acled_civi_ppp_qtr <- acled_civi_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_civi_ppp_km_qtr <- rescale.ppp(acled_civi_ppp_qtr,1000,'km')
    
    # compute KDE
    kde_acled_civi_qtr_bw_cvl <- density(
      acled_civi_ppp_km_qtr,
      sigma=bw.CvL,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_civi_list[[quarter]] <- kde_acled_civi_qtr_bw_cvl
    print('qtr done!')
}

kde_civi_list
```

```{r}
for (quarter in names(kde_civi_list)) {
    plot(kde_civi_list[[quarter]], main = paste("KDE for", quarter))
}
```

For other data export instructions, visit the link [here](https://acleddata.com/data-export-tool/).
