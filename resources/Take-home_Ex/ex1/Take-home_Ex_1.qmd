---
title: "Take-Home Exercise 1: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar"
author: "William"
date: "September 7, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

# Objectives of THE1

I will be using armed conflict [data](https://acleddata.com/data-export-tool/) of Myanmar from January 2021 to June 2024, aka Armed Conflict Location & Event Data (ACLED).

Along the way, I will be exploring the use of different functions to obtain more aesthetically pleasing outputs for fun, and documenting my findings and conclusion as and when needed.

# Data

## Packages

These R packages will be used:

-   **sf**: importing, managing, and processing geospatial data, and

-   **tidyverse**: performing data science tasks such as importing, wrangling and visualising data.

-   **readr**

    -   `read_csv()`: reading ACLED csv data

-   **janitor**: data cleaning

-   **lubridate**: date formatting

-   **sparr** : Spatio-temporal analysis

-   **Extra (TBD):**

    -   **janitor**: data cleaning

    -   **skimr**: provide summary statistics

    -   **raster**: `raster()`

    -   **terra**: `writeRaster()`

    -   **gridExtra, patchwork**: +**ggplot2** for ease of control of grid output layout

    -   **gganimate + gifski**: animated STKDE output

```{r}
pacman:::p_load(sf,tidyverse,sparr,spatstat,stpp,raster,terra,janitor,skimr,lubridate,tmap,gridExtra,patchwork,gganimate,gifski)
```

## ACLED

```{r}
#| eval: false
acled_sf <- read_csv('data/2021-01-01-2024-07-01-Myanmar.csv')
```

## Metadata

Click to expand –\>

<details>

+----------------------+----------------------------------------------------------------------------------------------------------+
| Variable             | Description                                                                                              |
+======================+:=========================================================================================================+
| 'event_id_cnty'      | unique alphanumeric ID by number & country acronym                                                       |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'event_date'         | day-month-year of event                                                                                  |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'year'               | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'time_precison'      | numeric code for level of precison of data records                                                       |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'disorder_type'      | i.e. 'Demonstrations','Political violence','Political violence; Demonstrations','Strategic developments' |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'event_type'         | nature of event                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'sub_event_type'     | provides further classification to event_type                                                            |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'actor1'             | involved actors along with their respective affiliates                                                   |
|                      |                                                                                                          |
| 'assoc_actor_1'      |                                                                                                          |
|                      |                                                                                                          |
| 'actor2'             |                                                                                                          |
|                      |                                                                                                          |
| 'assoc_actor_2'      |                                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'inter1'             | numeric code between 0 and 8 encoding different actors\                                                  |
|                      |                                                                                                          |
| 'inter2'             |                                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'interaction'        | indicates the 2 actor types interacting in the event (encoded inter1 & inter2 by concatenation)          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'civilian_targeting' | indicates whether the event involved civilian targeting (e.g. null if false)                             |
|                      |                                                                                                          |
|                      | -   **Note: no data format irregularity**                                                                |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'iso'                | unique 3-digit numeric code assigned to each country or territory according to ISO 3166                  |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'region'             | region of the world where the event took place                                                           |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'country'            | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'admin1'             | national administrative regions where the event took place (admin1 being the largest)                    |
|                      |                                                                                                          |
| 'admin2'             |                                                                                                          |
|                      |                                                                                                          |
| 'admin3'             |                                                                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'location'           | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'latitude'           | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'longitude'          | self-explanatory                                                                                         |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'geo_precision'      | numeric code for level of precison of event location                                                     |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'source'             | source of event report                                                                                   |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'source_scale'       | scale (e.g. local, international) of the source                                                          |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'notes'              | description of the event                                                                                 |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'fatalities'         | number of reported fatalities in the event                                                               |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'tags'               | targets (type and estimate counts)                                                                       |
+----------------------+----------------------------------------------------------------------------------------------------------+
| 'time'               | Unix Timestamp of event                                                                                  |
+----------------------+----------------------------------------------------------------------------------------------------------+

</details>

## Myammar's Administrative Boundary data

**Background:**

-   admin 0: country boundary (full overview)

-   1: state/region

-   2: district-level

-   3: township (greatest resolution)

**Approach:**

1.  In the working file directory, group the shapefiles according to admin classification (admin0, admin1, etc.)

2.  Load

3.  Check structure and boundary plot

For the purposes of exploring the differences in detail:

::: panel-tabset
### admin 0

```{r}
#| eval: false
the1_mymr_shp4326_admin0 <- st_read(dsn = 'data/gadm41_MMR_0/', layer = 'gadm41_MMR_0')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin0)

# geometry: "XY" "MULTIPOLYGON"
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin0$geometry)
```

### admin 1

```{r}

the1_mymr_shp4326_admin1 <- st_read(dsn = 'data/gadm41_MMR_1/', layer = 'gadm41_MMR_1')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin1)
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin1$geometry)
```

### admin 2

```{r}
#| eval: false
the1_mymr_shp4326_admin2 <- st_read(dsn = 'data/gadm41_MMR_2/', layer = 'gadm41_MMR_2')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin2)
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin2$geometry)
```

### admin 3

```{r}
#| eval: false
the1_mymr_shp4326_admin3 <- st_read(dsn = 'data/gadm41_MMR_3/', layer = 'gadm41_MMR_3')
```

```{r}
#| eval: false
str(the1_mymr_shp4326_admin3)
```

```{r}
#| eval: false
plot(the1_mymr_shp4326_admin3$geometry)
```
:::

### Study Area

To balance spatial detail and computational efficiency, I think using `the1_mymr_shp4326_admin1` (state/region) boundary data will be the best fit. While looking at district-/township-level provides fine granularity for analysis, for potato machines like my macbook, `the1_mymr_shp4326_admin1` provides the best compromise.

```{r}
#| eval: false
summary(the1_mymr_shp4326_admin1)
```

# Data Wrangling

In this section, I will be doing basic data cleaning and formatting across the ACLED columns so that I can derive appropriate variables needed for analysis.

**Inspecting ACLED**

```{r}
#| eval: false
head(acled_sf, n=5)
```

**Check ACLED structure**

```{r}
#| eval: false
str(acled_sf)
```

**Check `event_type` values**

```{r}
#| eval: false
unique(acled_sf$event_type)
```

**Check for Missing Data**

```{r}
#| eval: false
sum(is.na(acled_sf))
```

Clearly, this doesn't provide much insight to the state of the ACLED **columns**. Hence I consulted Uncle Google for alternatives:

-   base R

```{r}
#| eval: false
acled_sf %>% 
  summarise(across(everything(), ~ sum(is.na(.)))) %>% 
  
  # pivot_longer() to transpose the table for a more compact output
  pivot_longer(everything(), names_to = "column", values_to = "missing_count") %>%
  
  # filter() to rid off ACLED columns with no missing data.
  filter(missing_count > 0)
```

> Notes from output:
>
> '`actor`'-related columns: possible to have 1 or more actors responsible
>
> '`civilian_targeting`': boolean-like variable — null for no civilian targeting
>
> '`admin3`': location identifiers are still discernible at least 1 of the `admin` columns are filled
>
> '`tags`': supplementary target description information
>
> Hence, `missing_count` values can be ignored.

-   `skim()` from `skimr` package

```{r}
#| eval: false
skim(acled_sf) %>%
  tibble::as_tibble()

# n_missing, character.n_unique, various summary statistics are somwhat useful; added here for extra reference
```

**Checking for duplicates in ACLED's unique identifier `event_id_cnty`**

-   base R

```{r}
#| eval: false
sum(duplicated(acled_sf['event_id_cnty'])) # no duplicates
```

## Wrangling

#### Reference system

```{r}
#| eval: false
st_crs(acled_sf)
```

```{r}
#| eval: false
acled_sf <- acled_sf %>% 
  st_as_sf(coords = c('longitude','latitude'), crs = 4326) %>% 
  st_transform(crs = 32646)
st_crs(acled_sf) # last line: ID["EPSG",32646]]
```

```{r}
#| eval: false
st_crs(the1_mymr_shp4326_admin1) # last line: ID["EPSG",4326]]
```

```{r}

the1_mymr_shp32646_admin1 <- the1_mymr_shp4326_admin1 %>% 
  st_transform(crs = 32646)
st_crs(the1_mymr_shp32646_admin1) # now should be: ID["EPSG",32646]]
```

#### Date format

-   `lubridate` package

    -   `as_datetime()`: converts UNIX time-stamps into workable date-time object

    -   `quarter()`: extracts quarter info

```{r}
#| eval: false
# to-do: assign variable; mix in geospatial data too
acled_sf_prepped <- acled_sf %>% 
  group_by(event_id_cnty) %>%
  arrange(timestamp) %>% 
  mutate(
    # convert UNIX timestamp into datetime object
    datetime = as_datetime(timestamp, tz = 'Asia/Yangon'),
    
    # extract quarter info
    quarter_num = quarter(datetime),
    
    # concatenate
    quarter_period = paste(year,'Q', quarter_num, sep = '')
  ) %>% 
  ungroup()
```

> Note: Unix timestamps count the number of seconds since the Unix epoch (January 1st, 1970 at UTC)

## Saving Derived Data

Save working data files and check data structures and attributes if needed before proceeding with analysis

::: panel-tabset
### ACLED

```{r}
#| eval: false
acled_sf_prepped
```

### Boundary shapefile

```{r}
# | eval: false
the1_mymr_shp32646_admin1
```

### Derived Datasets

```{r}
#| eval: false
# refer to previously, 
# "Strategic developments"
# "Explosions/Remote violence"
# "Battles"
# "Protests"
# "Violence against civilians"
# "Riots"

acled_stratdev_sf <- acled_sf_prepped %>% 
  filter(event_type=='Strategic developments') %>% 
  dplyr::select(1,33,30,3,32) 
# if i did not specify dplyr unknown error pops: Error: unable to find an inherited method for function ‘select’ for signature ‘x = "sf"’

acled_explo_sf <- acled_sf_prepped %>% 
  filter(event_type=='Explosions/Remote violence') %>% 
  dplyr::select(1,33,30,3,32)

acled_battle_sf <- acled_sf_prepped %>% 
  filter(event_type=='Battles') %>% 
  dplyr::select(1,33,30,3,32)

acled_protest_sf <- acled_sf_prepped %>% 
  filter(event_type=='Protests') %>% 
  dplyr::select(1,33,30,3,32)

acled_civi_sf <- acled_sf_prepped %>% 
  filter(event_type=='Violence against civilians') %>% 
  dplyr::select(1,33,30,3,32)

acled_riot_sf <- acled_sf_prepped %>% 
  filter(event_type=='Riots') %>% 
  dplyr::select(1,33,30,3,32)

write_rds(acled_stratdev_sf, 'data/rds/acled_stratdev_sf.rds')
write_rds(acled_explo_sf, 'data/rds/acled_explo_sf.rds')
write_rds(acled_battle_sf, 'data/rds/acled_battle_sf.rds')
write_rds(acled_protest_sf, 'data/rds/acled_protest_sf.rds')
write_rds(acled_civi_sf, 'data/rds/acled_civi_sf.rds')
write_rds(acled_riot_sf, 'data/rds/acled_riot_sf.rds')

write_rds(acled_sf_prepped, 'data/rds/acled_sf_prepped.rds')
write_rds(the1_mymr_shp32646_admin1, 'data/rds/the1_mymr_shp32646_admin1.rds')
# event_id_cnty,1
# quarter_period,33
# geometry,30
```
:::

## RDS Checkpoint: `event_types` sf

```{r}
acled_sf_prepped <- read_rds('data/rds/acled_sf_prepped.rds')
the1_mymr_shp32646_admin1 <- read_rds('data/rds/the1_mymr_shp32646_admin1.rds')

acled_stratdev_sf <- read_rds('data/rds/acled_stratdev_sf.rds')
acled_explo_sf    <- read_rds('data/rds/acled_explo_sf.rds')
acled_battle_sf   <- read_rds('data/rds/acled_battle_sf.rds')
acled_protest_sf  <- read_rds('data/rds/acled_protest_sf.rds')
acled_civi_sf     <- read_rds('data/rds/acled_civi_sf.rds')
acled_riot_sf     <- read_rds('data/rds/acled_riot_sf.rds')
```

# Basemap Visualisation by `event_type`

## Overview plots by `event_type`

### Compute

```{r}
#| eval: false
# remove(p,plot,plot_list,events,event_type, event_type_list)

plot_list <- list()

event_type_list <- list(
  acled_battle_sf,
  acled_explo_sf,
  acled_protest_sf,
  acled_riot_sf,
  acled_stratdev_sf,
  acled_civi_sf
  )

event = sort(unique(acled_sf_prepped$event_type))

for (i in seq_along(event_type_list)) {
  event_type <- event_type_list[[i]]
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
  tm_shape(event_type) +
    tm_dots(size = 0.005) +
  tm_layout(title = toString(event[i]))
  plot_list[[i]] <- plot
}
```

> Note: Append the plots to a separate list, otherwise tmap plot will not work (due to how tmap output works)

### Save

```{r}
#| eval: false
write_rds(plot_list,'data/rds/event_overview_plot_list.rds')
```

### Visualise

```{r}
event_overview_plot_list <- read_rds('data/rds/event_overview_plot_list.rds')
tmap_arrange(event_overview_plot_list, ncol = 6)
```

## Quarterly plots

### Compute Quarterly plots

::: panel-tabset
#### Battles

```{r}
#| eval: false
# Extract unique quarters from the data
qtrs <- unique(acled_battle_sf$quarter_period)

# Create an empty list to store plots
plot_battle_list <- list()

# Loop through each unique quarter and generate plots
for (i in seq_along(qtrs)) {
  qtr <- qtrs[i]
  
  # Filter data for the current quarter
  qtr_data <- acled_battle_sf %>% filter(quarter_period==qtr)
  
  # Create plot for the current quarter
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
    tm_shape(qtr_data) +
    tm_dots(size = 0.005) +
    tm_layout(title = toString(qtr))
  
  # Store the plot in the list
  plot_battle_list[[i]] <- plot
}
```

#### Explosions/Remote violence

```{r}
#| eval: false
# Extract unique quarters from the data
qtrs <- unique(acled_explo_sf$quarter_period)

# Create an empty list to store plots
plot_explo_list <- list()

# Loop through each unique quarter and generate plots
for (i in seq_along(qtrs)) {
  qtr <- qtrs[i]
  
  # Filter data for the current quarter
  qtr_data <- acled_explo_sf %>% filter(quarter_period==qtr)
  
  # Create plot for the current quarter
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
    tm_shape(qtr_data) +
    tm_dots(size = 0.005) +
    tm_layout(title = toString(qtr))
  
  # Store the plot in the list
  plot_explo_list[[i]] <- plot
}
```

#### Protests

```{r}
#| eval: false
# Extract unique quarters from the data
qtrs <- unique(acled_protest_sf$quarter_period)

# Create an empty list to store plots
plot_protest_list <- list()

# Loop through each unique quarter and generate plots
for (i in seq_along(qtrs)) {
  qtr <- qtrs[i]
  
  # Filter data for the current quarter
  qtr_data <- acled_protest_sf %>% filter(quarter_period==qtr)
  
  # Create plot for the current quarter
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
    tm_shape(qtr_data) +
    tm_dots(size = 0.005) +
    tm_layout(title = toString(qtr))
  
  # Store the plot in the list
  plot_protest_list[[i]] <- plot
}
```

#### Riot

```{r}
#| eval: false
# Extract unique quarters from the data
qtrs <- unique(acled_riot_sf$quarter_period)

# Create an empty list to store plots
plot_riot_list <- list()

# Loop through each unique quarter and generate plots
for (i in seq_along(qtrs)) {
  qtr <- qtrs[i]
  
  # Filter data for the current quarter
  qtr_data <- acled_riot_sf %>% filter(quarter_period==qtr)
  
  # Create plot for the current quarter
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
    tm_shape(qtr_data) +
    tm_dots(size = 0.005) +
    tm_layout(title = toString(qtr))
  
  # Store the plot in the list
  plot_riot_list[[i]] <- plot
}
```

#### Strategic Developments

```{r}
#| eval: false
# Extract unique quarters from the data
qtrs <- unique(acled_stratdev_sf$quarter_period)

# Create an empty list to store plots
plot_stratdev_list <- list()

# Loop through each unique quarter and generate plots
for (i in seq_along(qtrs)) {
  qtr <- qtrs[i]
  
  # Filter data for the current quarter
  qtr_data <- acled_stratdev_sf %>% filter(quarter_period==qtr)
  
  # Create plot for the current quarter
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
    tm_shape(qtr_data) +
    tm_dots(size = 0.005) +
    tm_layout(title = toString(qtr))
  
  # Store the plot in the list
  plot_stratdev_list[[i]] <- plot
}
```

#### Violence against Civilian

```{r}
#| eval: false
# Extract unique quarters from the data
qtrs <- unique(acled_civi_sf$quarter_period)

# Create an empty list to store plots
plot_civi_list <- list()

# Loop through each unique quarter and generate plots
for (i in seq_along(qtrs)) {
  qtr <- qtrs[i]
  
  # Filter data for the current quarter
  qtr_data <- acled_civi_sf %>% filter(quarter_period==qtr)
  
  # Create plot for the current quarter
  plot <- tm_shape(the1_mymr_shp32646_admin1) +
    tm_polygons() +
    tm_shape(qtr_data) +
    tm_dots(size = 0.005) +
    tm_layout(title = toString(qtr))
  
  # Store the plot in the list
  plot_civi_list[[i]] <- plot
}
```
:::

### Save as RDS

```{r}
#| eval: false
write_rds(plot_battle_list, 'data/rds/plot_battle_list.rds')
write_rds(plot_explo_list, 'data/rds/plot_explo_list.rds')
write_rds(plot_protest_list, 'data/rds/plot_protest_list.rds')
write_rds(plot_riot_list, 'data/rds/plot_riot_list.rds')
write_rds(plot_stratdev_list, 'data/rds/plot_stratdev_list.rds')
write_rds(plot_civi_list, 'data/rds/plot_civi_list.rds')
```

```{r}
plot_battle_list   <- read_rds('data/rds/plot_battle_list.rds')
plot_explo_list    <- read_rds('data/rds/plot_explo_list.rds')
plot_protest_list  <- read_rds('data/rds/plot_protest_list.rds')
plot_riot_list     <- read_rds('data/rds/plot_riot_list.rds')
plot_stratdev_list <- read_rds('data/rds/plot_stratdev_list.rds')
plot_civi_list     <- read_rds('data/rds/plot_civi_list.rds')
```

### Visualise

::: panel-tabset
#### Battles

```{r}
# | eval: false
tmap_arrange(plot_battle_list, ncol = 4)
```

#### Explosions/Violence

```{r}
#| eval: false
tmap_arrange(plot_explo_list, ncol = 4)
```

#### Protests

```{r}
#| eval: false
tmap_arrange(plot_protest_list, ncol = 4)
```

#### Riots

```{r}
#| eval: false
tmap_arrange(plot_riot_list, ncol = 4)
```

#### Strategic Devs

```{r}
#| eval: false
tmap_arrange(plot_stratdev_list, ncol = 4)
```

#### Violence against Civilians

```{r}
#| eval: false
tmap_arrange(plot_civi_list, ncol = 4)
```
:::

# **First-order Spatial Point Patterns Analysis (SPPA)**

1st order SPPA deals with the variation of intensity (density) of points in a study area. In this context, I will be visualising the variation in the density of each `event_type` instances across the `admin 1` (state/region) boundaries.

## Overview KDEs

### Creating `ppp` object

**`as.ppp()` from `spatstat.geom`**

```{r}
acled_ppp <- as.ppp(acled_sf_prepped)
summary(acled_ppp)
```

### Creating `owin` object of `admin1` boundary

```{r}
the1_mymr_shp4326_admin1_owin <- as.owin(the1_mymr_shp32646_admin1)
```

### Combine ppp and owin

```{r}
acled_ppp <- acled_ppp[the1_mymr_shp4326_admin1_owin]
```

### Rescale `m` to `km`

```{r}
acled_ppp_km <- rescale.ppp(acled_ppp,1000,'km')
```

> Varying admin1 geographical boundaries — ideal adaptive bandwidth KDE, but because of **computational limitation**, fixed BW is used**:**

### Compute KDEs

#### Big Picture KDEs

```{r}
kde_acled_bw_diggle <- density(
  acled_ppp_km,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
```

```{r}
kde_acled_bw_scott <- density(
  acled_ppp_km,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
```

```{r}
kde_acled_bw_ppl <- density(
  acled_ppp_km,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)# choosing this
```

```{r}
kde_acled_bw_cvl <- density(
  acled_ppp_km,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
)
```

```{r}
par(mfrow=c(1,4))
plot(kde_acled_bw_cvl)
plot(kde_acled_bw_diggle)
plot(kde_acled_bw_ppl)
plot(kde_acled_bw_scott)
```

> Only `kde_acled_bw_cvl` and `kde_acled_bw_scott` produced discernible plots with notable differences:
>
> -   `kde_acled_bw_cvl` : **smoother —** provides a **cleaner** overall trend without excessive noise
>
> -   `kde_acled_bw_scott` : greater **detail —** capture small variations or nuances in the data
>
> -   Smoother plots might help with observing overall trends across quarterly `event_type` data, hence I will opt to use `bw_scott`

```{r}
table(acled_sf_prepped$admin1) %>% sort(decreasing = TRUE)
```

> From `kde_acled_bw_cvl` and `kde_acled_bw_scott` plots and the table counts of admin1, the 2 most apparent event clusters are situated at/in the **Sagaing-Mandalay city areas and Yangon city.**

#### `event_type` KDEs

```{r}
#| warning: false
#| eval: false
# rather simple to obtain so doesnt warrant converting to rds files
acled_battle_ppp <- as.ppp(acled_battle_sf)
acled_explo_ppp <- as.ppp(acled_explo_sf)
acled_protest_ppp <- as.ppp(acled_protest_sf)
acled_stratdev_ppp <- as.ppp(acled_stratdev_sf)
acled_civi_ppp <- as.ppp(acled_civi_sf)
```

```{r}
#| eval: false
acled_battle_ppp   <- acled_battle_ppp[the1_mymr_shp4326_admin1_owin]
acled_explo_ppp    <- acled_explo_ppp[the1_mymr_shp4326_admin1_owin]
acled_protest_ppp  <- acled_protest_ppp[the1_mymr_shp4326_admin1_owin]
acled_stratdev_ppp <- acled_stratdev_ppp[the1_mymr_shp4326_admin1_owin]
acled_civi_ppp     <- acled_civi_ppp[the1_mymr_shp4326_admin1_owin]
```

```{r}
#| eval: false
write_rds(acled_battle_ppp, 'data/rds/acled_battle_ppp.rds')
write_rds(acled_explo_ppp, 'data/rds/acled_explo_ppp.rds')
write_rds(acled_protest_ppp, 'data/rds/acled_protest_ppp.rds')
write_rds(acled_stratdev_ppp, 'data/rds/acled_stratdev_ppp.rds')
write_rds(acled_civi_ppp, 'data/rds/acled_civi_ppp.rds')
```

```{r}
acled_battle_ppp   <- read_rds('data/rds/acled_battle_ppp.rds')
acled_explo_ppp    <- read_rds('data/rds/acled_explo_ppp.rds')
acled_protest_ppp  <- read_rds('data/rds/acled_protest_ppp.rds')
acled_stratdev_ppp <- read_rds('data/rds/acled_stratdev_ppp.rds')
acled_civi_ppp     <- read_rds('data/rds/acled_civi_ppp.rds')
```

Even though only bw.CvL and bw.scout results in discernible plots, I will explore the use of the other 2 (diggle and ppl) bandwidths to be thorough.

## Battles

::: panel-tabset
### bw.CvL

```{r}
kde_battle_cvl <- density(
  acled_battle_ppp,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_battle_cvl)
```

### bw.scott

```{r}
kde_battle_scott <- density(
  acled_battle_ppp,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_battle_scott)
```

### bw.diggle

```{r}
kde_battle_diggle <- density(
  acled_battle_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_battle_diggle)
```

### bw.ppl

```{r}
kde_battle_ppl <- density(
  acled_battle_ppp,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_battle_ppl)
```
:::

```{r}
# in hindsight i should have included admin1 in the prepped dataset, but future me did not realise until the last minute
table((acled_sf_prepped %>% filter(event_type=="Battles"))$admin1) %>% sort(decreasing = TRUE)
```

> KDE Plots, verified with the above table counts, depict significant clusters of battles at **Sagaing-Magway areas**, **Shan-North, Kachin** and the near the start of Myanmar's 'tail' at **Kayin**
>
> Both `bw.CvL` and `bw.scott` yielded comparable plots in terms of smoothness but `bw.scott` is better in detail (more distinct clusters, less over-smoothing)

## Explosions/Remote violence

::: panel-tabset
### bw.CvL

```{r}
kde_explo_cvl <- density(
  acled_explo_ppp,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_explo_cvl)
```

### bw.scott

```{r}
kde_explo_scott <- density(
  acled_explo_ppp,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_explo_scott)
```

### bw.diggle

```{r}
kde_explo_diggle <- density(
  acled_explo_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_explo_diggle)
```

### bw.ppl

```{r}
kde_explo_ppl <- density(
  acled_explo_ppp,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_explo_ppl)
```
:::

```{r}
table((acled_sf_prepped %>% filter(event_type=="Explosions/Remote violence"))$admin1) %>% sort(decreasing = TRUE)
```

> Similar clustering patterns with Battle-type events with **one additional cluster at Yangon**
>
> Both `bw.CvL` and `bw.scott` yielded comparable plots in terms of smoothness but `bw.scott` is better in detail (more distinct clusters, less over-smoothing)

## Protests

::: panel-tabset
### bw.CvL

```{r}
kde_protest_cvl <- density(
  acled_protest_ppp,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_protest_cvl)
```

### bw.scott

```{r}
kde_protest_scott <- density(
  acled_protest_ppp,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_protest_scott)
```

### bw.diggle

```{r}
kde_protest_diggle <- density(
  acled_protest_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_protest_diggle)
```

### bw.ppl

```{r}
kde_protest_ppl <- density(
  acled_protest_ppp,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_protest_ppl)
```
:::

```{r}
table((acled_sf_prepped %>% filter(event_type=="Protests"))$admin1) %>% sort(decreasing = TRUE)
```

> Similar event clustering in the **Sagaing-Mandalay and Yangon** region (like those in Battles, Explosions/Violence) but seems more **localised** to those regions;
>
> This time`bw.scott` clearly yielded the best plot in terms of level of cluster detail: with reference to the bw.CvL plot, that middle-ish cluster turned out to be 2 distinct clusters in `bw.scott` 's plot.

## Strategic Developments

::: panel-tabset
### bw.CvL

```{r}
kde_stratdev_cvl <- density(
  acled_stratdev_ppp,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_stratdev_cvl)
```

### bw.scott

```{r}
kde_stratdev_scott <- density(
  acled_stratdev_ppp,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_stratdev_scott)
```

### bw.diggle

```{r}
kde_stratdev_diggle <- density(
  acled_stratdev_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_stratdev_diggle)
```

### bw.ppl

```{r}
kde_stratdev_ppl <- density(
  acled_stratdev_ppp,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_stratdev_ppl)
```
:::

```{r}
table((acled_sf_prepped %>% filter(event_type=="Strategic developments"))$admin1) %>% sort(decreasing = TRUE)
```

> Event clustering in the **Sagaing, Mandalay, Magway and Yangon** regions (like those in Battles, Explosions/Violence)
>
> At this juncture of the analysis, I have realised that while event clusters do occur in their corresponding admin1 regional boundaries, there is a significant portion of the respective regions that are likely rural (mountainous, undeveloped areas, dense forested areas, etc.). It is worth noting that while my current direction is to study the big picture and quarterly trends of event_types, zooming further down into the admin boundaries for conflict-prone areas should be done to gain more area-specific (district-/township- level) insights.
>
> Both `bw.CvL` and `bw.scott` yielded comparable plots in terms of smoothness but `bw.scott` is better in detail (more distinct clusters, less over-smoothing)

## Violence against Civilians

::: panel-tabset
### bw.CvL

```{r}
kde_civi_cvl <- density(
  acled_civi_ppp,
  sigma=bw.CvL,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_civi_cvl)
```

### bw.scott

```{r}
kde_civi_scott <- density(
  acled_civi_ppp,
  sigma=bw.scott,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_civi_scott)
```

### bw.diggle

```{r}
kde_civi_diggle <- density(
  acled_civi_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_civi_diggle)
```

### bw.ppl

```{r}
kde_civi_ppl <- density(
  acled_civi_ppp,
  sigma=bw.ppl,
  edge=TRUE,
  kernel='gaussian'
)
plot(kde_civi_ppl)
```
:::

```{r}
table((acled_sf_prepped %>% filter(event_type=="Violence against civilians"))$admin1) %>% sort(decreasing = TRUE)
```

> Both `bw.CvL` and `bw.scott` yielded comparable plots in terms of smoothness but `bw.scott` is better in detail (more distinct clusters, less over-smoothing)
>
> Similar clustering in the **Sagaing, Mandalay, Magway and Yangon,** with a new moderate cluster down south at **Tanintharyi** region.

## Quarterly KDE layers (excluding Riots)

### Compute

::: panel-tabset
#### Battles

```{r}
#| eval: false
#| warning: false
# initialise
quarters <- unique(acled_battle_sf$quarter_period)
kde_battles_list <- list()
ppp_battles_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_battle_sf_qtr <- acled_battle_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_battle_ppp_qtr <- as.ppp(acled_battle_sf_qtr)

    # create owin object
    acled_battle_ppp_qtr <- acled_battle_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_battle_ppp_km_qtr <- rescale.ppp(acled_battle_ppp_qtr,1000,'km')
    
    # Append ppp object to list
    ppp_battles_list[[quarter]] <- acled_battle_ppp_km_qtr
    
    # compute KDE
    kde_acled_battle_qtr_bw_cvl <- density(
      acled_battle_ppp_km_qtr,
      sigma=bw.scott,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_battles_list[[quarter]] <- kde_acled_battle_qtr_bw_cvl
    print('qtr done!')
}
```

#### Explosions/Violence

```{r}
#| eval: false
#| warning: false
# initialise
quarters <- unique(acled_explo_sf$quarter_period)
kde_explo_list <- list()
ppp_explo_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_explo_sf_qtr <- acled_explo_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_explo_ppp_qtr <- as.ppp(acled_explo_sf_qtr)

    # create owin object
    acled_explo_ppp_qtr <- acled_explo_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_explo_ppp_km_qtr <- rescale.ppp(acled_explo_ppp_qtr,1000,'km')
    
    # Append ppp object to list
    ppp_explo_list[[quarter]] <- acled_battle_ppp_km_qtr
    
    # compute KDE
    kde_acled_explo_qtr_bw_cvl <- density(
      acled_explo_ppp_km_qtr,
      sigma=bw.scott,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_explo_list[[quarter]] <- kde_acled_explo_qtr_bw_cvl
    print('qtr done!')
}
```

#### Protests

```{r}
#| eval: false
#| warning: false
# initialise
quarters <- unique(acled_protest_sf$quarter_period)
kde_protest_list <- list()
ppp_protest_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_protest_sf_qtr <- acled_protest_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_protest_ppp_qtr <- as.ppp(acled_protest_sf_qtr)

    # create owin object
    acled_protest_ppp_qtr <- acled_protest_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_protest_ppp_km_qtr <- rescale.ppp(acled_protest_ppp_qtr,1000,'km')
    
    # Append ppp object to list
    ppp_protest_list[[quarter]] <- acled_battle_ppp_km_qtr
    
    # compute KDE
    kde_acled_protest_qtr_bw_cvl <- density(
      acled_protest_ppp_km_qtr,
      sigma=bw.scott,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_protest_list[[quarter]] <- kde_acled_protest_qtr_bw_cvl
    print('qtr done!')
}
```

#### Strategic Devs

```{r}
#| eval: false
#| warning: false
# initialise
quarters <- unique(acled_stratdev_sf$quarter_period)
kde_stratdev_list <- list()
ppp_stratdev_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_stratdev_sf_qtr <- acled_stratdev_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_stratdev_ppp_qtr <- as.ppp(acled_stratdev_sf_qtr)

    # create owin object
    acled_stratdev_ppp_qtr <- acled_stratdev_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_stratdev_ppp_km_qtr <- rescale.ppp(acled_stratdev_ppp_qtr,1000,'km')
    
    # Append ppp object to list
    ppp_protest_list[[quarter]] <- acled_battle_ppp_km_qtr
    
    # compute KDE
    kde_acled_stratdev_qtr_bw_cvl <- density(
      acled_stratdev_ppp_km_qtr,
      sigma=bw.scott,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_stratdev_list[[quarter]] <- kde_acled_stratdev_qtr_bw_cvl
    print('qtr done!')
}
```

#### Violence against Civilians

```{r}
#| eval: false
#| warning: false
# initialise
quarters <- unique(acled_civi_sf$quarter_period)
kde_civi_list <- list()
ppp_civi_list <- list()

# test
# acled_battle_sf %>% filter(quarter_period=='2021Q1')

for (quarter in quarters) {

    # filter quarter
    acled_civi_sf_qtr <- acled_civi_sf %>% filter(quarter_period == quarter)

    # create ppp object
    acled_civi_ppp_qtr <- as.ppp(acled_civi_sf_qtr)

    # create owin object
    acled_civi_ppp_qtr <- acled_civi_ppp_qtr[the1_mymr_shp4326_admin1_owin]
    
    # rescale to KM
    acled_civi_ppp_km_qtr <- rescale.ppp(acled_civi_ppp_qtr,1000,'km')
    
    # Append ppp object to list
    ppp_protest_list[[quarter]] <- acled_battle_ppp_km_qtr
    
    # compute KDE
    kde_acled_civi_qtr_bw_cvl <- density(
      acled_civi_ppp_km_qtr,
      sigma=bw.scott,
      edge=TRUE,
      kernel='gaussian'
    )
    
    # Append to list
    kde_civi_list[[quarter]] <- kde_acled_civi_qtr_bw_cvl
    print('qtr done!')
}
```
:::

### Save as RDS

```{r}
#| eval: false
write_rds(kde_battles_list, 'data/rds/kde_battles_list.rds')
write_rds(kde_explo_list, 'data/rds/kde_explo_list.rds')
write_rds(kde_protest_list, 'data/rds/kde_protest_list.rds')
write_rds(kde_stratdev_list, 'data/rds/kde_stratdev_list.rds')
write_rds(kde_civi_list, 'data/rds/kde_civi_list.rds')
```

```{r}
#| eval: false
write_rds(ppp_battles_list, 'data/rds/ppp_battles_list.rds')
write_rds(ppp_explo_list, 'data/rds/ppp_explo_list.rds')
write_rds(ppp_protest_list, 'data/rds/ppp_protest_list.rds')
write_rds(ppp_stratdev_list, 'data/rds/ppp_stratdev_list.rds')
write_rds(ppp_civi_list, 'data/rds/ppp_civi_list.rds')
```

```{r}
ppp_battles_list  <- read_rds('data/rds/kde_battles_list.rds')
ppp_explo_list    <- read_rds('data/rds/kde_explo_list.rds')
ppp_protest_list  <- read_rds('data/rds/kde_protest_list.rds')
ppp_stratdev_list <- read_rds('data/rds/kde_stratdev_list.rds')
ppp_civi_list     <- read_rds('data/rds/kde_civi_list.rds')
```

```{r}
kde_battles_list  <- read_rds('data/rds/kde_battles_list.rds')
kde_explo_list    <- read_rds('data/rds/kde_explo_list.rds')
kde_protest_list  <- read_rds('data/rds/kde_protest_list.rds')
kde_stratdev_list <- read_rds('data/rds/kde_stratdev_list.rds')
kde_civi_list     <- read_rds('data/rds/kde_civi_list.rds')
```

### Visualise

::: panel-tabset
#### Battles

```{r}
#| eval: false
# Create a list to store ggplot objects
kde_plots <- list()

# Loop through each KDE and create a ggplot object
for (quarter in names(kde_battles_list)) {
  kde_df <- as.data.frame(kde_battles_list[[quarter]])  # Convert KDE raster to data frame
  
  # Create a plot
  p <- ggplot() +
    geom_raster(aes(x, y, fill = value), data = kde_df) +
    scale_fill_viridis_c() +
    ggtitle(paste("KDE for", quarter)) +
    
    # Reduce the size of titles, legends, and axis text
    theme_minimal() +
    theme(
      plot.title = element_text(size = 5),               # Reduce title size
      axis.title = element_blank(),                      # Remove axis titles
      axis.text = element_text(size = 5),                # Minimize axis text size
      legend.title = element_text(size = 5),             # Reduce legend title size
      legend.text = element_text(size = 5),              # Reduce legend text size
      legend.key.size = unit(0.3, "cm"),                 # Minimize legend key size
      plot.margin = margin(1, 1, 1, 1, "mm")             # Minimize margins around the plot
    )
  
  kde_plots[[quarter]] <- p
}

# Combine plots into a grid with 4 columns
combined_plot <- wrap_plots(kde_plots) + plot_layout(ncol = 4)
# Display the combined plot
combined_plot
```

-   Battle clusters seem to be most localised in Q1 and Q2 of all years excluding 2024

-   Battle density appear to have a cycle until 2024: where battle events disperses around its initial dense cluster location as time passes from Q1 to Q4

-   2024 data seem sparse or spread out.

#### Explosions/Violence

```{r}
#| eval: false
# Create a list to store ggplot objects
kde_plots <- list()

# Loop through each KDE and create a ggplot object
for (quarter in names(kde_explo_list)) {
  kde_df <- as.data.frame(kde_explo_list[[quarter]])  # Convert KDE raster to data frame
  
  # Create a plot
  p <- ggplot() +
    geom_raster(aes(x, y, fill = value), data = kde_df) +
    scale_fill_viridis_c() +
    ggtitle(paste("KDE for", quarter)) +
    
    # Reduce the size of titles, legends, and axis text
    theme_minimal() +
    theme(
      plot.title = element_text(size = 5),               # Reduce title size
      axis.title = element_blank(),                      # Remove axis titles
      axis.text = element_text(size = 5),                # Minimize axis text size
      legend.title = element_text(size = 5),             # Reduce legend title size
      legend.text = element_text(size = 5),              # Reduce legend text size
      legend.key.size = unit(0.3, "cm"),                 # Minimize legend key size
      plot.margin = margin(1, 1, 1, 1, "mm")             # Minimize margins around the plot
    )
  
  kde_plots[[quarter]] <- p
}

# Combine plots into a grid with 4 columns
combined_plot <- wrap_plots(kde_plots) + plot_layout(ncol = 4)
# Display the combined plot
combined_plot
```

-   Clusters often appear to re-converge at the same regions as previously mentioned under the corresponding 'event_type KDEs' section

-   Again, 2024 data seem sparse or spread out

#### Protests

```{r}
#| eval: false
# Create a list to store ggplot objects
kde_plots <- list()

# Loop through each KDE and create a ggplot object
for (quarter in names(kde_protest_list)) {
  kde_df <- as.data.frame(kde_protest_list[[quarter]])  # Convert KDE raster to data frame
  
  # Create a plot
  p <- ggplot() +
    geom_raster(aes(x, y, fill = value), data = kde_df) +
    scale_fill_viridis_c() +
    ggtitle(paste("KDE for", quarter)) +
    
    # Reduce the size of titles, legends, and axis text
    theme_minimal() +
    theme(
      plot.title = element_text(size = 5),               # Reduce title size
      axis.title = element_blank(),                      # Remove axis titles
      axis.text = element_text(size = 5),                # Minimize axis text size
      legend.title = element_text(size = 5),             # Reduce legend title size
      legend.text = element_text(size = 5),              # Reduce legend text size
      legend.key.size = unit(0.3, "cm"),                 # Minimize legend key size
      plot.margin = margin(1, 1, 1, 1, "mm")             # Minimize margins around the plot
    )
  
  kde_plots[[quarter]] <- p
}

# Combine plots into a grid with 4 columns
combined_plot <- wrap_plots(kde_plots) + plot_layout(ncol = 4)
# Display the combined plot
combined_plot
```

-   In general, significant protest clusters are far and few between; the few clusters that exists are much more localised within the regions previously mentioned under the corresponding 'event_type KDEs' section

-   The sparse pattern makes sense given the oppressive nature of the conflict on civilians.

#### Strategic Devs

```{r}
#| eval: false
# Create a list to store ggplot objects
kde_plots <- list()

# Loop through each KDE and create a ggplot object
for (quarter in names(kde_stratdev_list)) {
  kde_df <- as.data.frame(kde_stratdev_list[[quarter]])  # Convert KDE raster to data frame
  
  # Create a plot
  p <- ggplot() +
    geom_raster(aes(x, y, fill = value), data = kde_df) +
    scale_fill_viridis_c() +
    ggtitle(paste("KDE for", quarter)) +
    
    # Reduce the size of titles, legends, and axis text
    theme_minimal() +
    theme(
      plot.title = element_text(size = 5),               # Reduce title size
      axis.title = element_blank(),                      # Remove axis titles
      axis.text = element_text(size = 5),                # Minimize axis text size
      legend.title = element_text(size = 5),             # Reduce legend title size
      legend.text = element_text(size = 5),              # Reduce legend text size
      legend.key.size = unit(0.3, "cm"),                 # Minimize legend key size
      plot.margin = margin(1, 1, 1, 1, "mm")             # Minimize margins around the plot
    )
  
  kde_plots[[quarter]] <- p
}

# Combine plots into a grid with 4 columns
combined_plot <- wrap_plots(kde_plots) + plot_layout(ncol = 4)
# Display the combined plot
combined_plot
```

-   In general, the event clusters appear to have relatively similar locality, albeit their densities seem to be fluctuating throughout the time period

#### Violence against Civilians

```{r}
#| eval: false
# Create a list to store ggplot objects
kde_plots <- list()

# Loop through each KDE and create a ggplot object
for (quarter in names(kde_civi_list)) {
  kde_df <- as.data.frame(kde_civi_list[[quarter]])  # Convert KDE raster to data frame
  
  # Create a plot
  p <- ggplot() +
    geom_raster(aes(x, y, fill = value), data = kde_df) +
    scale_fill_viridis_c() +
    ggtitle(paste("KDE for", quarter)) +
    
    # Reduce the size of titles, legends, and axis text
    theme_minimal() +
    theme(
      plot.title = element_text(size = 5),               # Reduce title size
      axis.title = element_blank(),                      # Remove axis titles
      axis.text = element_text(size = 5),                # Minimize axis text size
      legend.title = element_text(size = 5),             # Reduce legend title size
      legend.text = element_text(size = 5),              # Reduce legend text size
      legend.key.size = unit(0.3, "cm"),                 # Minimize legend key size
      plot.margin = margin(1, 1, 1, 1, "mm")             # Minimize margins around the plot
    )
  
  kde_plots[[quarter]] <- p
}
# Combine plots into a grid with 4 columns
combined_plot <- wrap_plots(kde_plots) + plot_layout(ncol = 4)
# Display the combined plot
combined_plot
```

-   Clusters often appear to re-converge at the same regions as previously mentioned under the corresponding 'event_type KDEs' section

-   Mostly widespread
:::

# Second-order Spatial Point Patterns Analysis

Now, after studying the variation of point density, I will be studying the **spatial relationship between points**, to see if it clustered, dispersed or completely random (complete spatial randomness, CSR) at different distances. In order to do that, I will be using G-, F-, K-, and L-Functions for each `event_type`

## Set Seed

```{r}
set.seed(69)
```

## G-Function (Nearest Neighbor Distance)

::: panel-tabset
### Battles

**Computing G-function estimation**

```{r}
#| eval: false
G_battles <- Gest(acled_battle_ppp, correction = "border")
plot(G_battles, xlim=c(0,500))
```

**Performing CSR Test**

```{r}
#| eval: false
G_battles.csr <- envelope(acled_battle_ppp, Gest, nsim = 39)
plot(G_battles.csr)
```

### Explosions/Violence

```{r}
#| eval: false
G_explo <- Gest(acled_explo_ppp, correction = "border")
plot(G_explo, xlim=c(0,500))
```

```{r}
#| eval: false
G_explo.csr <- envelope(acled_explo_ppp, Gest, nsim = 39)
plot(G_explo.csr)
```

### Protests

```{r}
#| eval: false
G_protest <- Gest(acled_protest_ppp, correction = "border")
plot(G_protest, xlim=c(0,500))
```

```{r}
#| eval: false
G_protest.csr <- envelope(acled_protest_ppp, Gest, nsim = 39)
plot(G_protest.csr)
```

### Strategic Devs

```{r}
#| eval: false
G_stratdev <- Gest(acled_stratdev_ppp, correction = "border")
plot(G_stratdev, xlim=c(0,500))
```

```{r}
#| eval: false
G_stratdev.csr <- envelope(acled_stratdev_ppp, Gest, nsim = 39)
plot(G_stratdev.csr)
```

### Violence against Civilians

```{r}
#| eval: false
G_civi <- Gest(acled_civi_ppp, correction = "border")
plot(G_civi, xlim=c(0,500))
```

```{r}
#| eval: false
G_civi.csr <- envelope(acled_civi_ppp, Gest, nsim = 39)
plot(G_civi.csr)
```

### Conclusion

All plots strongly indicate clustering of events of every type (above the CSR line)
:::

## F-Function (Empty Space Function)

::: panel-tabset
### Battles

**Computing F-function estimation**

```{r}
#| eval: false
F_battles <- Fest(acled_battle_ppp)
plot(F_battles)
```

**Performing CSR Test**

```{r}
#| eval: false
F_battles.csr <- envelope(acled_battle_ppp, Fest, nsim = 39)
plot(F_battles.csr)
```

### Explosions/Violence

```{r}
#| eval: false
F_explo <- Fest(acled_explo_ppp)
plot(F_explo)
```

```{r}
#| eval: false
F_explo.csr <- envelope(acled_explo_ppp, Fest, nsim = 39)
plot(F_explo.csr)
```

### Protests

```{r}
#| eval: false
F_protest <- Fest(acled_protest_ppp)
plot(F_protest)
```

```{r}
#| eval: false
F_protest.csr <- envelope(acled_protest_ppp, Fest, nsim = 39)
plot(F_protest.csr)
```

### Strategic Devs

```{r}
#| eval: false
F_stratdev <- Fest(acled_stratdev_ppp)
plot(F_stratdev)
```

```{r}
#| eval: false
F_stratdev.csr <- envelope(acled_stratdev_ppp, Fest, nsim = 39)
plot(F_stratdev.csr)
```

### Violence against Civilians

```{r}
#| eval: false
F_civi <- Fest(acled_civi_ppp)
plot(F_civi)
```

```{r}
#| eval: false
F_civi.csr <- envelope(acled_civi_ppp, Fest, nsim = 39)
plot(F_civi.csr)
```

### Conclusion

All plots strongly indicate a dispersed pattern, or large between-event point distances (below the CSR line)
:::

## K-Function (Ripley's K Function)

::: panel-tabset
### Battles

```{r}
#| eval: false
K_battles = Kest(acled_battle_ppp, correction = "Ripley")
plot(K_battles, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
K_battles.csr <- envelope(acled_battle_ppp, Kest, nsim = 39, rank = 1, glocal=TRUE)
plot(K_battles.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### Explosions/Violence

```{r}
#| eval: false
K_explo = Kest(acled_explo_ppp, correction = "Ripley")
plot(K_explo, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
K_explo.csr <- envelope(acled_explo_ppp, Kest, nsim = 39, rank = 1, glocal=TRUE)
plot(K_explo.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### Protests

```{r}
#| eval: false
K_protest = Kest(acled_protest_ppp, correction = "Ripley")
plot(K_protest, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
K_protest.csr <- envelope(acled_protest_ppp, Kest, nsim = 39, rank = 1, glocal=TRUE)
plot(K_protest.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### Strategic Devs

```{r}
#| eval: false
K_stratdev = Kest(acled_stratdev_ppp, correction = "Ripley")
plot(K_stratdev, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
K_stratdev.csr <- envelope(acled_stratdev_ppp, Kest, nsim = 39, rank = 1, glocal=TRUE)
plot(K_stratdev.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### Violence against Civilians

```{r}
#| eval: false
K_civi = Kest(acled_civi_ppp, correction = "Ripley")
plot(K_civi, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
K_civi.csr <- envelope(acled_civi_ppp, Kest, nsim = 39, rank = 1, glocal=TRUE)
plot(K_civi.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### Conclusion

All plots strongly indicate clustering of events at every given distance (above the CSR line)
:::

## L-Function (Besag’s L Function)

::: panel-tabset
### Battles

```{r}
#| eval: false
L_battles = Lest(acled_battle_ppp, correction = "Ripley")
plot(L_battles, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
L_battles.csr <- envelope(acled_battle_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)
plot(L_battles.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r")
```

### Explosions/Violence

```{r}
#| eval: false
L_explo = Lest(acled_explo_ppp, correction = "Ripley")
plot(L_explo, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
L_explo.csr <- envelope(acled_explo_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)
plot(L_explo.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r")
```

### Protests

```{r}
#| eval: false
L_protest = Lest(acled_protest_ppp, correction = "Ripley")
plot(L_protest, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
L_protest.csr <- envelope(acled_protest_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)
plot(L_protest.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r")
```

### Strategic Devs

```{r}
#| eval: false
L_stratdev = Lest(acled_stratdev_ppp, correction = "Ripley")
plot(L_stratdev, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
L_stratdev.csr <- envelope(acled_stratdev_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)
plot(L_stratdev.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r")
```

### Violence against Civilians

```{r}
#| eval: false
L_civi = Lest(acled_civi_ppp, correction = "Ripley")
plot(L_civi, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
#| eval: false
L_civi.csr <- envelope(acled_civi_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)
plot(L_civi.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r")
```

### Conclusion

It is odd that all CSR lines lie along x-axis (or very near it), because it means all L-functions have positive deviations from its corresponding CSR line, indicating strong spatial dependence / clustering as observed under the K-function section
:::

# First-order Spatio-Temporal Point Patterns Analysis (STPPA)

I will be using BOOT.spattemp() to optimise the spatial bandwidth and the scalar temporal bandwidth, to avoid having sparse data in the quarterly STKDEs.

In this case, because the previous KDEs seem to indicate that events tend to occur in a spatially concentrated manner, I opt to use the event-specific OWIN object for the STKDE computation to find out if theres also a temporal pattern within each event.

::: panel-tabset
### Battle

**Compute**

```{r}
# runtime: <30s

# initialise variables
stkde_battle_results <- list()
qtr <- c(1,2,3,4)
years <- unique(acled_battle_sf$year)

# loop thru by year then then quarter
for (yr in years){
    temp_sf <- acled_battle_sf %>% filter(year==yr)
    
    # incase there's no data in the year (unlikely though)
    if (nrow(temp_sf) == 0) next
    
    temp_ppp <- temp_sf %>% dplyr::select(quarter_num) %>% as.ppp()
    temp_ppp <- temp_ppp[the1_mymr_shp4326_admin1_owin]
    temp_stkde <- spattemp.density(temp_ppp)

    for (q in qtr){
      # terminate condition
      if (yr == 2024 & q > 3) {
        break
      }
      # Extracting density values from `temp_stkde`
      density_matrix <- temp_stkde$z[[q]]$v  # 'v'   : density 
      x_vals <- temp_stkde$z[[q]]$xcol       # 'xcol': x-coordinates
      y_vals <- temp_stkde$z[[q]]$yrow       # 'yrow': y-coordinates
      
      # vector-ise matrices to convert to dataframe
      density_df <- expand.grid(x = x_vals, y = y_vals)
      density_df$density <- as.vector(density_matrix)
      
      stkde_battle_results[[paste(yr, q, sep = 'Q')]] <- data.frame(
        x = density_df$x, 
        y = density_df$y, 
        density = density_df$density, 
        year = yr, 
        quarter = q
    )
    }
}
```

> Note:
>
> Initially use `spattemp.density` default parameters

**Configure Visualisation**

```{r}
# runtime: <30s
# Combine the results into one data frame
stkde_battle_combined <- do.call(rbind, stkde_battle_results)


# Create a ggplot and animate over the 'year' and 'quarter'
battle_anime <- ggplot(stkde_battle_combined, aes(x = y, y = x, fill = density)) + # flip axes
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  
  theme(aspect.ratio = 3) +  # Adjust this value to stretch vertically

  labs(title = 'Spatio-Temporal Kernel Density Estimation', subtitle = 'Year: {closest_state}') +
  coord_fixed() +
  transition_states(paste(year, quarter, sep = "Q"), state_length = 1) +
  ease_aes('linear')

# save 
battle_animation <- animate(battle_anime, duration = 10, renderer = gifski_renderer())
anim_save(
  filename = 'battle_animation.gif',
  animation = battle_animation, 
  path = 'animation/battle/')
```

**Output GIF**

![](animation/battle/battle_animation.gif){width="600"}

![]()

> Note:
>
> After the first render, set `eval: false` for the "Compute" and "Configure Visualisation", otherwise a new GIF will be created, replacing the previous one.
>
> Current workaround: delete the previous GIF so that the new one will be referenced successfully.
>
> For the following `event_types` , I encountered a 'sparse data' error so I played around with different spatial bandwidths (bw.diggle, bw.ppl), different temporal bandwidths (90 for quarter; 365 for a year).

### Explosion/Violence

**Compute**

```{r}
# runtime: <5min

# initialise variables
stkde_explo_results <- list()
qtr <- c(1,2,3,4)
years <- unique(acled_explo_sf$year)

# loop thru by year then then quarter
for (yr in years){
    temp_sf <- acled_explo_sf %>% filter(year==yr)
    
    # incase there's no data in the year (unlikely though)
    if (nrow(temp_sf) == 0) next
    
    temp_ppp <- temp_sf %>% dplyr::select(quarter_num) %>% as.ppp()
    temp_ppp <- temp_ppp[the1_mymr_shp4326_admin1_owin]
    temp_stkde <- spattemp.density(
      temp_ppp,
      # h = bw.diggle(temp_ppp), # conflict events are concentrated in some regions
      h = 5*bw.ppl(temp_ppp), # larger, more generalised bandwidth
      lambda = 90
    )
    
    for (q in qtr){
      # terminate condition
      if (yr == 2024 & q > 3) {
        break
      }
      # Extracting density values from `temp_stkde`
      density_matrix <- temp_stkde$z[[q]]$v  # 'v'   : density 
      x_vals <- temp_stkde$z[[q]]$xcol       # 'xcol': x-coordinates
      y_vals <- temp_stkde$z[[q]]$yrow       # 'yrow': y-coordinates
      
      # vector-ise matrices to convert to dataframe
      density_df <- expand.grid(x = x_vals, y = y_vals)
      density_df$density <- as.vector(density_matrix)
      
      stkde_explo_results[[paste(yr, q, sep = 'Q')]] <- data.frame(
        x = density_df$x, 
        y = density_df$y, 
        density = density_df$density, 
        year = yr, 
        quarter = q
    )
    }
}
```

**Configure Visualisation**

```{r}
# runtime: <30s
# Combine the results into one data frame
stkde_explo_combined <- do.call(rbind, stkde_explo_results)


# Create a ggplot and animate over the 'year' and 'quarter'
explo_anime <- ggplot(stkde_explo_combined, aes(x = y, y = x, fill = density)) + # flip axes
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  
  theme(aspect.ratio = 3) +  # Adjust this value to stretch vertically

  labs(title = 'Spatio-Temporal Kernel Density Estimation', subtitle = 'Year: {closest_state}') +
  coord_fixed() +
  transition_states(paste(year, quarter, sep = "Q"), state_length = 1) +
  ease_aes('linear')

# save 
explo_animation <- animate(explo_anime, duration = 10, renderer = gifski_renderer())
anim_save(
  filename = 'explo_animation.gif',
  animation = explo_animation, 
  path = 'animation/explosion_violence/')
```

**Output GIF**

![](animation/explosion_violence/explo_animation.gif){width="600"}

### Protests

**Compute**

```{r}
# runtime: <10min

# initialise variables
stkde_protest_results <- list()
qtr <- c(1,2,3,4)
years <- unique(acled_protest_sf$year)

# loop thru by year then then quarter
for (yr in years){
    temp_sf <- acled_protest_sf %>% filter(year==yr)
    
    # incase there's no data in the year (unlikely though)
    if (nrow(temp_sf) == 0) next
    
    temp_ppp <- temp_sf %>% dplyr::select(quarter_num) %>% as.ppp()
    temp_ppp <- temp_ppp[the1_mymr_shp4326_admin1_owin]
    temp_stkde <- spattemp.density(
      temp_ppp,
      h = 5*bw.ppl(temp_ppp), 
      lambda = 90
      )

    for (q in qtr){
      # terminate condition
      if (yr == 2024 & q > 3) {
        break
      }
      # Extracting density values from `temp_stkde`
      density_matrix <- temp_stkde$z[[q]]$v  # 'v'   : density 
      x_vals <- temp_stkde$z[[q]]$xcol       # 'xcol': x-coordinates
      y_vals <- temp_stkde$z[[q]]$yrow       # 'yrow': y-coordinates
      
      # vector-ise matrices to convert to dataframe
      density_df <- expand.grid(x = x_vals, y = y_vals)
      density_df$density <- as.vector(density_matrix)
      
      stkde_protest_results[[paste(yr, q, sep = 'Q')]] <- data.frame(
        x = density_df$x, 
        y = density_df$y, 
        density = density_df$density, 
        year = yr, 
        quarter = q
    )
    }
}
```

**Configure Visualisation**

```{r}
# runtime: <30s
# Combine the results into one data frame
stkde_protest_combined <- do.call(rbind, stkde_protest_results)


# Create a ggplot and animate over the 'year' and 'quarter'
protest_anime <- ggplot(stkde_protest_combined, aes(x = y, y = x, fill = density)) + # flip axes
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  
  theme(aspect.ratio = 3) +  # Adjust this value to stretch vertically

  labs(title = 'Spatio-Temporal Kernel Density Estimation', subtitle = 'Year: {closest_state}') +
  coord_fixed() +
  transition_states(paste(year, quarter, sep = "Q"), state_length = 1) +
  ease_aes('linear')

# save 
protest_animation <- animate(protest_anime, duration = 10, renderer = gifski_renderer())
anim_save(
  filename = 'protest_animation.gif',
  animation = protest_animation, 
  path = 'animation/protests/')
```

**Output GIF**

![](animation/protests/protest_animation.gif){width="600"}

### Strategic Developments

**Compute**

```{r}
# runtime: <5mins

# initialise variables
stkde_stratdev_results <- list()
qtr <- c(1,2,3,4)
years <- unique(acled_stratdev_sf$year)

# loop thru by year then then quarter
for (yr in years){
    temp_sf <- acled_stratdev_sf %>% filter(year==yr)
    
    # incase there's no data in the year (unlikely though)
    if (nrow(temp_sf) == 0) next
    
    temp_ppp <- temp_sf %>% dplyr::select(quarter_num) %>% as.ppp()
    temp_ppp <- temp_ppp[the1_mymr_shp4326_admin1_owin]
    temp_stkde <- spattemp.density(
      temp_ppp,
      h = 5*bw.ppl(temp_ppp), 
      lambda = 90
      )
    
    for (q in qtr){
      # terminate condition
      if (yr == 2024 & q > 3) {
        break
      }
      # Extracting density values from `temp_stkde`
      density_matrix <- temp_stkde$z[[q]]$v  # 'v'   : density 
      x_vals <- temp_stkde$z[[q]]$xcol       # 'xcol': x-coordinates
      y_vals <- temp_stkde$z[[q]]$yrow       # 'yrow': y-coordinates
      
      # vector-ise matrices to convert to dataframe
      density_df <- expand.grid(x = x_vals, y = y_vals)
      density_df$density <- as.vector(density_matrix)
      
      stkde_stratdev_results[[paste(yr, q, sep = 'Q')]] <- data.frame(
        x = density_df$x, 
        y = density_df$y, 
        density = density_df$density, 
        year = yr, 
        quarter = q
    )
    }
}
```

**Configure Visualisation**

```{r}
# runtime: <30s
# Combine the results into one data frame
stkde_stratdev_combined <- do.call(rbind, stkde_stratdev_results)


# Create a ggplot and animate over the 'year' and 'quarter'
stratdev_anime <- ggplot(stkde_stratdev_combined, aes(x = y, y = x, fill = density)) + # flip axes
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  
  theme(aspect.ratio = 3) +  # Adjust this value to stretch vertically

  labs(title = 'Spatio-Temporal Kernel Density Estimation', subtitle = 'Year: {closest_state}') +
  coord_fixed() +
  transition_states(paste(year, quarter, sep = "Q"), state_length = 1) +
  ease_aes('linear')

# save 
stratdev_animation <- animate(stratdev_anime, duration = 10, renderer = gifski_renderer())
anim_save(
  filename = 'stratdev_animation.gif',
  animation = stratdev_animation, 
  path = 'animation/strategic_development/')
```

**Output GIF**

![](animation/strategic_development/stratdev_animation.gif){width="600"}

### Violence against Civilians

**Compute**

```{r}
# runtime: <5mins

# initialise variables
stkde_civi_results <- list()
qtr <- c(1,2,3,4)
years <- unique(acled_civi_sf$year)

# loop thru by year then then quarter
for (yr in years){
    temp_sf <- acled_civi_sf %>% filter(year==yr)
    
    # incase there's no data in the year (unlikely though)
    if (nrow(temp_sf) == 0) next
    
    temp_ppp <- temp_sf %>% dplyr::select(quarter_num) %>% as.ppp()
    temp_ppp <- temp_ppp[the1_mymr_shp4326_admin1_owin]
    temp_stkde <- spattemp.density(
      temp_ppp,
      h = 5*bw.ppl(temp_ppp), # raised the multiplier for fun -- turned out to have most balance
      lambda = 90
      )
    
    for (q in qtr){
      # terminate condition
      if (yr == 2024 & q > 3) {
        break
      }
      # Extracting density values from `temp_stkde`
      density_matrix <- temp_stkde$z[[q]]$v  # 'v'   : density 
      x_vals <- temp_stkde$z[[q]]$xcol       # 'xcol': x-coordinates
      y_vals <- temp_stkde$z[[q]]$yrow       # 'yrow': y-coordinates
      
      # vector-ise matrices to convert to dataframe
      density_df <- expand.grid(x = x_vals, y = y_vals)
      density_df$density <- as.vector(density_matrix)
      
      stkde_civi_results[[paste(yr, q, sep = 'Q')]] <- data.frame(
        x = density_df$x, 
        y = density_df$y, 
        density = density_df$density, 
        year = yr, 
        quarter = q
    )
    }
}
```

**Configure Visualisation**

```{r}
# runtime: <30s
# Combine the results into one data frame
stkde_civi_combined <- do.call(rbind, stkde_civi_results)


# Create a ggplot and animate over the 'year' and 'quarter'
civi_anime <- ggplot(stkde_civi_combined, aes(x = y, y = x, fill = density)) + # flip axes
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  
  theme(aspect.ratio = 3) +  # Adjust this value to stretch vertically

  labs(title = 'Spatio-Temporal Kernel Density Estimation', subtitle = 'Year: {closest_state}') +
  coord_fixed() +
  transition_states(paste(year, quarter, sep = "Q"), state_length = 1) +
  ease_aes('linear')

# save 
civi_animation <- animate(civi_anime, duration = 10, renderer = gifski_renderer())
anim_save(
  filename = 'civi_animation.gif',
  animation = civi_animation, 
  path = 'animation/violence_against_civi/')
```

**Output GIF**

![](animation/violence_against_civi/civi_animation.gif){width="600"}
:::

# Second-order STPPA

Because of the additional time dimension factored in by the spatio-temporal KDE object, I figured that I cannot (at least should not) use the second-order SPPA methods of G-Function, F-Function, K-Function, and L-Function. However after consulting with Uncle Google, I discovered that the K-function has extensions that cover the temporal domain:

### `stpp::STIKhat()`

-   **inhomogeneous version** of the **K-function**; adjusts for variations in point density across space and time

-   Why inhomogeneous?

    -   Since ACLED is obviously real–world data, it will not follow a uniform distribution: certain regions of Myanmar are hotspots for conflict, while others have sparse data on such events(evidently from the dot plots and KDE figures above). Hence I thought that by using `STIKhat()` , I can detect clusters while factoring in these density differences.

#### Prepare coordinates

```{r}
coords <- st_coordinates(acled_battle_sf)
x <- coords[, 1]  # long
y <- coords[, 2]  # lat
```

#### Prepare time variable by converting into numeric

```{r}
# Convert quarter_period to numeric time 
# Compute the numeric time value as the number of quarters since 2021Q1
acled_battle_sf$time <- ((acled_battle_sf$year - 2021) * 4) + acled_battle_sf$quarter_num
unique(acled_battle_sf$time) # should be 15 quarters in total
t <- acled_battle_sf$time
```

> I needed to convert the time periods into a continuous Numeric Value for `stpp::STIKhat()` , by:
>
> -   **`acled_battle_sf$year - 2021`**: Years have passed since 2021
>
> -   **`*4`**: Convert years to quarters
>
> -   **`+ acled_battle_sf$quarter`**: Adds the quarter (1 for Q1, 2 for Q2, etc.)

#### Compute

```{r}

# Create spatio-temporal point pattern object
stpp_battle <- as.3dpoints(x = x, y = y, t = t)

# Run STIKhat to compute the inhomogeneous K-function
stikhat_battle_result <- STIKhat(stpp_battle)
str(stikhat_battle_result)
```

> It is possible that overlapping event_data are repeat conflicts rather than erroneous data collection; either way I chose to jitter rather than remove to hopefully maintain the overall structure
>
> Also, I already checked for duplicate data earlier, hence can ignore the 'Warning: Space-time data contains duplicated points', probably due to the repeated t values.

#### Plot against distance

```{r}
k_values <- stikhat_battle_result$Khat
# str(k_values)
k_theoretical <- stikhat_battle_result$Ktheo
distances <- stikhat_battle_result$dist
# length(k_values)

# Create the plot
plot(
  distances, 
  k_values[2,], # or k_values[1,]
  type = "l", 
  col = "blue", 
  main = "STIK-function for Battles",
  xlab = "distance", ylab = "K-func",
  ylim = range(c(k_values[2,], k_theoretical[2,]))
  )

# Add the theoretical K-function to the plot
lines(distances, k_theoretical[2,], type = "l", col = "red") # or k_theoretical[1,]

# Add a legend
legend("topleft", legend = c("Observed", "Theoretical"),
       col = c("blue", "red"), lty = 1)
```

#### Plot against time

```{r}
k_values <- stikhat_battle_result$Khat
k_theoretical <- stikhat_battle_result$Ktheo
times <- stikhat_battle_result$times

# Create the plot
plot(
  times, 
  k_values[2,], # or k_values[1,]
  type = "l", 
  col = "blue", 
  main = "STIK-function for Battles",
  xlab = "time", ylab = "K-func",
  ylim = range(c(k_values[2,], k_theoretical[2,]))
  )

# Add the theoretical K-function to the plot
lines(times, k_theoretical[2,], type = "l", col = "red") # or k_theoretical[1,]

# Add a legend
legend("topleft", legend = c("Observed K-function", "Theoretical K-function"),
       col = c("blue", "red"), lty = 1)
```

> The upward steps of Observed K-function seems to coincide at certain distances and/or time periods.
>
> indicate that at could be explained by distances or the time; but it seems there are significantly more battle events than expected possibly due to the existence of more conflict-prone hotspots in Myanmar.

# `tmap` plots

## KDEs

```{r}
# KDEs used:
# kde_battle_scott
# kde_explo_scott
# kde_protest_scott
# kde_stratdev_scott
# kde_civi_scott
```

**Convert KDEs into Spatial Grids**

```{r}
gridded_kde_battle   <- as(kde_battle_scott, "SpatialGridDataFrame")
gridded_kde_explo    <- as(kde_explo_scott, "SpatialGridDataFrame")
gridded_kde_protest  <- as(kde_protest_scott, "SpatialGridDataFrame")
gridded_kde_stratdev <- as(kde_stratdev_scott, "SpatialGridDataFrame")
gridded_kde_civi     <- as(kde_civi_scott, "SpatialGridDataFrame")
```

**View gridded objects**

::: panel-tabset
### Battles

```{r}
spplot(gridded_kde_battle)
```

### Explosions/Violence

```{r}
spplot(gridded_kde_explo)
```

### Protest

```{r}
spplot(gridded_kde_protest)
```

### Strategic Developments

```{r}
spplot(gridded_kde_stratdev)
```

### Violence against civilians

```{r}
spplot(gridded_kde_civi)
```
:::

**Convert into rasters**

```{r}
raster_kde_battle <- raster(gridded_kde_battle)
raster_kde_explo <- raster(gridded_kde_explo)
raster_kde_protest <- raster(gridded_kde_protest)
raster_kde_stratdev <- raster(gridded_kde_stratdev)
raster_kde_civi <- raster(gridded_kde_civi)
```

**Assign EPSG code**

```{r}
projection(raster_kde_battle) <- CRS("+init=EPSG:3414")
projection(raster_kde_explo) <- CRS("+init=EPSG:3414")
projection(raster_kde_protest) <- CRS("+init=EPSG:3414")
projection(raster_kde_stratdev) <- CRS("+init=EPSG:3414")
projection(raster_kde_civi) <- CRS("+init=EPSG:3414")
```

## Visualise

```{r}
tmap_mode('plot')
```

::: panel-tabset
### Battles

```{r}
#| warning: false
tm_shape(raster_kde_battle) +
  tm_raster("v") +
  tm_layout(legend.position = c("left","bottom"),frame=FALSE)
```

### Explosions/Violence

```{r}
#| warning: false
tm_shape(raster_kde_explo) +
  tm_raster("v") +
  tm_layout(legend.position = c("left","bottom"),frame=FALSE)
```

### Protest

```{r}
#| warning: false
tm_shape(raster_kde_protest) +
  tm_raster("v") +
  tm_layout(legend.position = c("left","bottom"),frame=FALSE)
```

### Strategic Developments

```{r}
#| warning: false
tm_shape(raster_kde_stratdev) +
  tm_raster("v") +
  tm_layout(legend.position = c("left","bottom"),frame=FALSE)
```

### Violence against civilians

```{r}
#| warning: false
tm_shape(raster_kde_civi) +
  tm_raster("v") +
  tm_layout(legend.position = c("left","bottom"),frame=FALSE)
```
:::

# Learnings

Data wrangling makes all the difference in the overall analysis. There times where I did not extract crucial data columns I needed for later sections and had to re-adjust, ruining the analysis workflow.

I followed the "throw and see what sticks" process, where I first employed methods learnt and discovered online to gain insights. For example, in my second-order STPPA, I then focused on a single method to evaluate my results because I realised other statistical methods did not extend to the temporal domain directly.

Reading documentation is underrated. I mostly had to self-learn the animated visualisation methods, so internalising all the required parameters and their corresponding object type was also a significant challenge

Overall, it was fun (not quite) :/
